// 4CE, 1AC, if you're able to design the right algorithm with just one shot, why failed by 4 foolish CEs?/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    void reorderList(ListNode *head) {        // IMPORTANT: Please reset any member data you declared, as        // the same Solution instance will be reused for each test case.        if(head == nullptr){            // 1CE here, void function...            return;        }                int n, n1, n2;        // 1CE here, ListNode, not List...        ListNode *h1, *h2, *ptr;                h1 = head;        ptr = head;        n = 0;        while(ptr != nullptr){            ++n;            ptr = ptr->next;        }        n1 = (n + 1) / 2;        n2 = n - n1;        ptr = head;        // 1CE here, declaration for $i missing        for(int i = 1; i < n1; ++i){            ptr = ptr->next;        }        h2 = ptr->next;        ptr->next = nullptr;        h2 = reverseList(h2);                ListNode *root = new ListNode(0), *tail;        ListNode *p1, *p2;        tail = root;        while(h1 != nullptr || h2 != nullptr){            if(h1 != nullptr){                tail->next = h1;                h1 = h1->next;                tail = tail->next;                tail->next = nullptr;            }            if(h2 != nullptr){                tail->next = h2;                h2 = h2->next;                tail = tail->next;                tail->next = nullptr;            }        }                head = root->next;        delete root;        // 1CE here, void function has no return    }private:    ListNode *reverseList(ListNode *head) {        if(nullptr == head){            return head;        }                ListNode *ptr1, *ptr2, *root;                root = new ListNode(0);        ptr1 = head;        while(ptr1 != nullptr){            ptr2 = root->next;            root->next = ptr1;            ptr1 = ptr1->next;            root->next->next = ptr2;        }                head = root->next;        delete root;        return head;    }};